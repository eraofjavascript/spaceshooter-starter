<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Hold-to-Rotate Camera</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; cursor: none; touch-action: none; }
  </style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
  // Scene and camera
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 0);

  // Renderer
  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Starfield
  const starCount = 2000;
  const starsGeometry = new THREE.BufferGeometry();
  const starPositions = new Float32Array(starCount * 3);
  for (let i = 0; i < starCount * 3; i++) {
    starPositions[i] = (Math.random() - 0.5) * 2000;
  }
  starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
  const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
  const starField = new THREE.Points(starsGeometry, starsMaterial);
  scene.add(starField);

  // Cube attached to camera
  const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
  const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
  const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
  camera.add(cube);
  cube.position.set(0, 0, -5);
  scene.add(camera);

  // Rotation state
  let verticalAngle = 0;
  let rotationSpeed = 0; // current speed (rad/frame)
  const baseSpeed = 0.01; // speed of rotation

  // Mobile touch
  window.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      const startY = e.touches[0].clientY;

      const handleMove = (moveEvent) => {
        const deltaY = moveEvent.touches[0].clientY - startY;
        if (deltaY < 0) rotationSpeed = baseSpeed; // swipe up → rotate up
        else if (deltaY > 0) rotationSpeed = -baseSpeed; // swipe down → rotate down
      };

      window.addEventListener('touchmove', handleMove, { passive: false });

      const handleEnd = () => {
        rotationSpeed = 0; // stop on release
        window.removeEventListener('touchmove', handleMove);
        window.removeEventListener('touchend', handleEnd);
      };

      window.addEventListener('touchend', handleEnd);
    }
  });

  // PC mouse (right button)
  let isRightDragging = false;
  let startY = 0;

  window.addEventListener('mousedown', (e) => {
    if (e.button === 2) { // right button
      isRightDragging = true;
      startY = e.clientY;
    }
  });

  window.addEventListener('mousemove', (e) => {
    if (isRightDragging) {
      const deltaY = e.clientY - startY;
      rotationSpeed = deltaY < 0 ? baseSpeed : -baseSpeed;
    }
  });

  window.addEventListener('mouseup', (e) => {
    if (e.button === 2) {
      isRightDragging = false;
      rotationSpeed = 0; // stop rotation
    }
  });

  window.addEventListener('contextmenu', e => e.preventDefault());

  function animate() {
    requestAnimationFrame(animate);

    verticalAngle += rotationSpeed;
    camera.rotation.x = verticalAngle;

    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>
